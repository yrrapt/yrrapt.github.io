[{"content":"Notes about algorithmic design such as $$ g_m / I_d $$ techniques.\n","date":-62135596800,"description":"","objectID":"423e98b4b850ab534cbde71e4dd09cdf","permalink":"https://yrrapt.github.io/analogue/design/algorithmicdesign/","title":"Algorithmic Design"},{"content":"Ideal Current Source To design the amplifier we will start with two design specifications: the DC gain and the gain-bandwidth product (GBW).\nThese described as:\n$$ A_{DC} = g_m \\cdot r_o$$\n$$ GBW = \\frac{ g_m }{ 2 \\pi C_L }$$\nLet\u0026amp;rsquo;s use an example spec:\n   Parameter Specification     $$ A_{DC} $$ 40 dB   $$ GBW $$ 1 MHz   $$ C_L $$ 10 pF    Let\u0026amp;rsquo;s rearrange using $$ \\frac{g_m}{I_d} $$ as a parameter:\n$$ g_m = GBW \\cdot 2 \\pi C_L $$ $$ I_d = \\frac{g_m}{ \\left( \\frac{g_m}{I_d} \\right) } $$ $$ I_d = \\frac{GBW \\cdot 2 \\pi C_L}{ \\left( \\frac{g_m}{I_d} \\right) } $$\nLet\u0026amp;rsquo;s select $$ \\frac{g_m}{I_d} = 18 $$ this equates to an inversion coefficient of 1 [Gm/ID versus IC]\nTherefore:\n$$ I_d = \\frac{ 10~MHz \\cdot 2 \\pi \\cdot 10~pF }{18} = 35~\\mu A $$\n","date":-62135596800,"description":"","objectID":"6e332988caa6ccb9d2ea60bb17baee44","permalink":"https://yrrapt.github.io/analogue/design/algorithmicdesign/common-source/common-source/","title":"Common Source"},{"content":" Internal and External Op-Amp Compensation: A Control-Centric Tutorial  ","date":-62135596800,"description":"","objectID":"497100c0ba73f42f8c4cae2ff9bb8932","permalink":"https://yrrapt.github.io/analogue/design/control/references/","title":"Control / Stability References"},{"content":"Electromagnetics \\[ P = \\frac{1}{2} \\oint_S \\mathbf{E} \\times \\mathbf{H}^* = \\cdot d\\mathbf{s} = P_l + 2 j \\omega ~ (W_m - W_e) \\]\nLumped Model Design \nInductance \\[ L_S = \\beta ~ d^{\\alpha_1}_{out} ~ w^{\\alpha_2} ~ d^{\\alpha_3}_{avg} ~ n^{\\alpha_4} ~ s^{\\alpha_5} ~~~ [nH]\\]\nSeries Resistance \\[ R_s = l / ( \\sigma ~ w ~ \\delta ~ (1 - e^{-t/\\delta})) = k_1 ~ l/w \\]\n\\[ \\delta = \\sqrt{ 2 / (w ~ \\mu ~ \\sigma) } \\]\nSubstrate Oxide Capacitance \\[ C_{ox} = (\\epsilon_{ox} ~ l ~ w) / 2~ t_{ox} = k_2 ~ l ~ w \\]\nSeries Capacitance \\[ C_s = (\\epsilon_{ox} ~ n ~ w^2) / (t_{ox,M1-M2}) = k_3 ~ n ~ w^2 \\]\nSubstrate Capacitance \\[ C_{sub} = (C_{sub,specifc} ~ l ~ w) / 2 = k_4 ~ l ~ w \\]\nSubstrate Resistance \\[ R_{sub} = 2 / (G_{sub,specifc} ~ l ~ w) / 2 = k_5 / (l ~ w) \\]\nIntegration into Oscillators Considering an inductor used in a tank circuit of an LC oscillator the Noise to Carrier Ratio can be expressed as:\n\\[ \\frac{\\left}{V_{tank}^2} \\propto \\begin{cases} L_{g^2_L} / I^2_{bias} ~~~(L~limited) \\\\ L ~~~~~~~~~~~~~~~~ (V~limited) \\\\ \\end{cases} \\]\nIn the voltage limited regime increasing the inductance beyond the value that puts the oscillator at the edge of the voltage-limited regime will create a waste of inductance. The current also should not be increased beyond the limit of voltage and inductance limited regions to avoid the waste of power.\n","date":1608472923,"description":"","lastmod":"2020-12-20T15:02:03+01:00","objectID":"cbe81b155c208abeab7f506e4f2dc62f","permalink":"https://yrrapt.github.io/analogue/design/inductor/inductor-design/","publishdate":"2020-12-20T15:02:03+01:00","title":"Inductor Design"},{"content":" On-Chip Spiral Inductors for RF Applications: An Overview A Fundamental Approach for Design and Optimization of a Spiral Inductor Concepts and Methods in Optimization of Integrated LC VCOs Simple Accurate Expressions for Planar Spiral Inductances Optimization of Inductor Circuits via Geometric Programming  ","date":-62135596800,"description":"","objectID":"2e3bf170f228e0072e42ebd0437d3188","permalink":"https://yrrapt.github.io/analogue/design/inductor/references/","title":"Inductor References"},{"content":"\nTank Inductance \\[ L_{tank} = \\left[ 1 + {(R_s / (L_s \\omega))}^2 \\right] L_s \\]\nTank Capacitance \\[ C_{tank} = C_{ad} + C_{tot} = C_{load} + C_{tot} \\]\nTank Resistance \\[ R_{tank} = R_p \\parallel R_{s,p} = {(1/R_p + 1/R_{s,p} )}^{-1} \\]\nFor \\( Q_{tank}  1.5 \\):\n\\[ R_{s,p} = \\left[ (1 + {(L_s \\omega / R_s)}^2 \\right] R_s \\approx {(L_s \\omega)}^2 / R_s \\]\nGeometric Program \\[ maximise ~~~~ R_{tank} \\]\n\\[ subject~to ~~~ L_{tank} ( C_{tank} + C_{tot} + C_{min} ) \\leq 1/\\omega^2_{max}\\]\n\\[ (r-1)(C_{tot} + C_{load})/C_{max} + r C_{min} / C_{max} \\leq 1 \\]\n\\[ C_{min} \\geq \\alpha C_{max} \\]\n\\[ Q_{tank} \\geq Q_{tank,min} \\]\n\\[ ... \\]\n","date":1608472923,"description":"","lastmod":"2020-12-20T15:02:03+01:00","objectID":"9d62f76ff968167cbc21d5ca4c204db6","permalink":"https://yrrapt.github.io/analogue/design/inductor/tank-design/","publishdate":"2020-12-20T15:02:03+01:00","title":"Tank Design"},{"content":"Notes about inductors.\n","date":1608472923,"description":"","lastmod":"2020-12-20T15:02:03+01:00","objectID":"3afa34c77b6fafafbd243cdadf9bb36e","permalink":"https://yrrapt.github.io/analogue/design/inductor/","title":"Inductors"},{"content":"Transfer Functions  [1]\nConsidering the system above, the transfer functions of the loop are:\nOpen Loop Transfer Function:\n\\[ G(s) = \\frac{ \\theta_o (s) }{ \\theta_o (e) } = \\frac{K_d ~ K_o ~ F(s)}{s} \\]\nSystem Transfer Function:\n\\[ H(s) = \\frac{ \\theta_o (s) }{ \\theta_i (e) } = \\frac{G(s)}{1 + G(s)} = \\frac{K_d ~ K_o ~ F(s)}{s + K_d ~ K_o ~ F(s)} \\]\nError Transfer Function:\n\\[ E(s) = \\frac{ \\theta_e (s) }{ \\theta_i (e) } = \\frac{1}{1 + G(s)} = 1 - H(s) = \\frac{s}{s + K_d ~ K_o ~ F(s)} \\]\nLoop Filter Consider an idealied first order loop filter with equations:\n\\[ \\tau_1 = R_1 C \\]\n\\[ \\tau_2 = R_2 C \\]\n\\[ F(s) \\approx -\\frac{s \\tau_2 + 1}{s \\tau_1} = - \\left( \\frac{\\tau_2}{\\tau_1} + \\frac{1}{s \\tau_1} \\right)\\]\nThis can also be represented as PI (Proportional Integral) gains:\n\\[ F(s) = K_1 + \\frac{K_2}{s} \\]\nSecond Order PLL Once the loop filter (or better named loop controller) above is combined with the system transfer function the system becomes second order:\n\\[ H(s) = \\frac{ K_d~K_o (s \\tau_2 + 1) / \\tau_1 }{ s^2 + s~K_d~K_o~\\tau_2/\\tau_1 + K_d~K_o/\\tau_1 } = \\frac{K_d~K_o (K_1 s + K_2)}{s^2 + s~K_d~K_o~K_1 + K_d~K_o~K_2} \\]\nThe two roots of the denomintor for the poles of the transfer function. The zero is the root of the numerator and lies at \\( s = -1 / \\tau_2 = -K_2/K_1 \\).\nMore important than the order of the PLL is the type. The type is the number of poles at zero, this is the number of integrators in the system. Most PLLs are type 2.\nNatural Frequency and Damping The second-order system can be described using the undamped natural frequency \\( \\omega_n \\) and the damping ratio, \\( \\zeta \\). These are defined as:\n\\[ \\omega_n = \\sqrt{\\frac{K_d K_o}{\\tau_1}} = \\sqrt{K_d K_o K_2} \\]\n\\[ \\zeta = \\frac{\\tau_2}{2} \\sqrt{\\frac{K_d K_o}{\\tau_1}} = \\frac{\\tau_2 \\omega_2}{2} = \\frac{K_1}{2} \\sqrt{\\frac{K_d K_o}{K_2}} \\]\nNote that the natural frequency is a function of the oscillator and detector gain and also the integral gain but not the proportional gain.\nA higher …","date":-62135596800,"description":"","objectID":"5132b6b10f3bf33ac0cbc5c2f0aaed88","permalink":"https://yrrapt.github.io/analogue/design/pll/pll-system/","title":"PLL Systems"},{"content":"Jitter Considering the jitter from a white noise source on a sinusoidal signal described by:\n\\[ v(t) = A sin( \\omega_0 t) + n(t) \\]\nGiven the assumption that the amplitude of the signal is much greater than the noise the transition times are only slightly modified. The small signal approximation can be made where:\n\\[ v(t) \\approx A \\omega_0 t + n(t) \\]\nFind when the signal equals zero at time moment k.\n\\[ 0 \\approx A \\omega_0 t_k + n_k \\]\nThus,\n\\[ t_k \\approx \\frac{n_k}{A \\omega_0} \\]\nTherefore, the jitter increases with larger noise amplitude, smaller signal amplitude or lower frequency.\nThe discrete-time noise process \\( n_k \\) is white with variance \\( \\sigma^2_n \\). Hence absolute jitter is also a discrete-time white noise process with variance:\n\\[ \\sigma^2_\\tau = \\frac{\\sigma^2_n}{A^2 \\omega^2_0} \\]\nThe sequence \\( \\tau_k \\) is the absolute jitter of the clock in time units. It can be normalised to radians:\n\\[ \\phi_k = \\tau_k \\frac{2 \\pi}{T_0} = \\frac{\\sigma^2_n}{A^2}\\]\nThe noise in radians is expressed as:\n\\[ \\sigma^2_\\phi = \\sigma^2_\\tau \\cdot {\\left( \\frac{2 \\pi}{T_0} \\right)}^2 = \\frac{\\sigma^2_n}{A^2} \\]\nPhase Noise Phase noise is the frequency-domain representation of absolute jitter. The phase noise, \\( S_\\phi(f) \\), of a clock signal with random jitter is the power spectral density of the sequence \\( \\phi_k \\). It specifies the power of \\( \\phi_k \\) in \\( rad^2 \\) within any 1 Hz wide bin of frequency spectrum and has units \\( rad^2 / Hz \\).\nThe variance of \\( \\phi_k \\) is given by the integral of \\( S_\\phi(f) \\) over all frequencies:\n\\[ \\sigma^2_\\tau = {\\left ( \\frac{T_0}{2 \\pi} \\right)}^2 \\int^{1/2T_0}_0 S_\\phi (f) \\cdot df \\]\nNormalised Power Spectral Density Below an ideal oscillator is shown with a single frequency component. A realistic representation is also shown jitter with power around the ideal single tone. The greater the jitter the more the power will be spread around the ideal frequency. The power in the tails is also proportional to the …","date":-62135596800,"description":"","objectID":"6ce8dc569cce7220266c433412d526c5","permalink":"https://yrrapt.github.io/analogue/design/pll/phase-noise/","title":"Jitter and Phase Noise Principles"},{"content":" Spur Reduction Techniques for Phase-Locked Loops Exploiting A Sub-Sampling Phase Detector A Noise-Shifting Differential Colpitts VCO Spur Reduction Techniques for Phase-Locked Loops Exploiting A Sub-Sampling Phase Detector A General Theory of Phase Noise in Electrical Oscillators  ","date":-62135596800,"description":"","objectID":"b59764e75ba72ed72fa2b9b1665d004d","permalink":"https://yrrapt.github.io/analogue/design/pll/references/","title":"PLL References"},{"content":"The impedance for a parallel RLC for \\( \\Delta \\omega is:\n\\[ Z(\\omega_0 + \\Delta \\omega) \\approx \\frac{1}{G_L} \\cdot \\frac{1}{1 + j 2 Q_L \\frac{\\Delta \\omega}{\\omega_0} } \\]\nwhere \\( G_L \\) is the parallel parasitic conductance of the tank. For steady-state oscillation \\( G_m R_L = \\frac{G_m}{G_L} = 1 \\).\nIn an oscillator the active device provides energy to compensate for losses in the tank circuit and sustain oscillation. It supplies DC energy to the tank but also injects noise which becomes phase noise.\nDifferential Colpitts  Differential Colpitts[2]\n [1] A. Hajimiri and T. H. Lee, \u0026amp;quot;A general theory of phase noise in electrical oscillators,\u0026amp;quot; in IEEE Journal of Solid-State Circuits, vol. 33, no. 2, pp. 179-194, Feb. 1998, doi: 10.1109/4.658619.\n[2] R. Aparicio and A. Hajimiri, \u0026amp;quot;A noise-shifting differential Colpitts VCO\u0026amp;quot; in IEEE Journal of Solid-State Circuits, vol. 37, no. 12, pp. 1728-1736, Dec. 2002, doi: 10.1109/JSSC.2002.804354.\n","date":-62135596800,"description":"","objectID":"fd62fa6f7e5280dfb9e5de133de21072","permalink":"https://yrrapt.github.io/analogue/design/pll/vco-design/","title":"LC VCO Design"},{"content":"","date":-62135596800,"description":"","objectID":"b7d57c36cc56d1084411eb0cfbaecad2","permalink":"https://yrrapt.github.io/analogue/design/pll/","title":"PLL"},{"content":"Phase Noise  Efficient transient noise analysis of non-periodic mixed analogue/digital circuits  ","date":-62135596800,"description":"","objectID":"1542359853c05602b56d7338daa8e1fd","permalink":"https://yrrapt.github.io/analogue/design/simulation/references/","title":"Simulation References"},{"content":"Notes about design.\n","date":1490227200,"description":"","lastmod":"2017-03-23T00:00:00Z","objectID":"02e0f483cea2e38f39ceb042265c10ee","permalink":"https://yrrapt.github.io/analogue/design/","publishdate":"2017-03-24T00:00:00Z","title":"Design"},{"content":"ADC Verification Techniques ADC DNL/INL Measurement From https://www.reddit.com/r/chipdesign/comments/g9fsyg/dnlinl_of_adc_in_cadence:\n I never use the DNL \u0026amp;amp; INL calculator. It is so easy to get garbage answers with it. I\u0026amp;rsquo;ve never figured out how to do it reliably. Luckily, it is trivial to do this in Python. First, strobe the output codes of the ADC at the sampling rate and then save them to a file. Just a list. So, the list would look like: 0 0 0 0 0 0 0 ... 0 1 1 1 1 1 1 ... 1 2 2 2 2 2... 2 and so on.\nThen in Python, MATLAB, or whatever, read in the file and find the average number of samples per code (this is easy, just divide the total number of samples you have by the 2^N of your ADC where N is the resolution). This is your expected value of samples in each code bin.\nThen, do a loop over each code (from 0 to (2^N - 1)). The DNL for each code is simply the difference between the number of codes for that code divided by the average number of samples per code (the expected value). The INL is simply the previous INL plus the current DNL value (i.e the running sum for all previous DNLs value plus the current DNL value). Make sure to initialize INL to 0.\nThat\u0026amp;rsquo;s all there is to it. Just be sure to use an ideal voltage source for the ramp.\nIf you want to do a sine test, it is more involved, but still pretty easy.\nSo, one more thing, how many points do you need? The DNL resolution is 1/(Number of samples per code).\nSo, if you want to know your DNL to 0.1 LSB accuracy, you need 10 samples per code. So if you have a 12-bit ADC, you need 10*2^10 = 10,240 samples minimum.\nUsually you probably want more like 0.01 LSB accuracy so you would need 102,400 samples. If you do a sine test you need WAY more.\n ","date":1608472923,"description":"","lastmod":"2020-12-20T15:02:03+01:00","objectID":"92b30bde21c8fea54745b9648efae8cf","permalink":"https://yrrapt.github.io/analogue/verification/adc_verification/","publishdate":"2020-12-20T15:02:03+01:00","title":"ADC Verification Techniques"},{"content":"","date":1608472923,"description":"","lastmod":"2020-12-20T15:02:03+01:00","objectID":"a2160426b90e5d643fafd1d4c85e0e6c","permalink":"https://yrrapt.github.io/analogue/verification/","title":"Verification"},{"content":"","date":1608472923,"description":"","lastmod":"2020-12-20T15:02:03+01:00","objectID":"d07003b780667fc2b806c1f10301c642","permalink":"https://yrrapt.github.io/analogue/","title":"Analogue"}]