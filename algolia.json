[{"content":"Notes about algorithmic design such as $$ g_m / I_d $$ techniques.\n","date":-62135596800,"description":"","objectID":"423e98b4b850ab534cbde71e4dd09cdf","permalink":"https://yrrapt.github.io/analogue/design/algorithmicdesign/","title":"Algorithmic Design"},{"content":"Ideal Current Source To design the amplifier we will start with two design specifications: the DC gain and the gain-bandwidth product (GBW).\nThese described as:\n$$ A_{DC} = g_m \\cdot r_o$$\n$$ GBW = \\frac{ g_m }{ 2 \\pi C_L }$$\nLet\u0026amp;rsquo;s use an example spec:\n   Parameter Specification     $$ A_{DC} $$ 40 dB   $$ GBW $$ 1 MHz   $$ C_L $$ 10 pF    Let\u0026amp;rsquo;s rearrange using $$ \\frac{g_m}{I_d} $$ as a parameter:\n$$ g_m = GBW \\cdot 2 \\pi C_L $$ $$ I_d = \\frac{g_m}{ \\left( \\frac{g_m}{I_d} \\right) } $$ $$ I_d = \\frac{GBW \\cdot 2 \\pi C_L}{ \\left( \\frac{g_m}{I_d} \\right) } $$\nLet\u0026amp;rsquo;s select $$ \\frac{g_m}{I_d} = 18 $$ this equates to an inversion coefficient of 1 [Gm/ID versus IC]\nTherefore:\n$$ I_d = \\frac{ 10~MHz \\cdot 2 \\pi \\cdot 10~pF }{18} = 35~\\mu A $$\n","date":-62135596800,"description":"","objectID":"6e332988caa6ccb9d2ea60bb17baee44","permalink":"https://yrrapt.github.io/analogue/design/algorithmicdesign/common-source/common-source/","title":"Common Source"},{"content":" Internal and External Op-Amp Compensation: A Control-Centric Tutorial  ","date":-62135596800,"description":"","objectID":"497100c0ba73f42f8c4cae2ff9bb8932","permalink":"https://yrrapt.github.io/analogue/design/control/references/","title":"Control / Stability References"},{"content":"\\[ P = \\frac{1}{2} \\oint_S \\mathbf{E} \\times \\mathbf{H}^* = \\cdot d\\mathbf{s} = P_l + 2 j \\omega ~ (W_m - W_e) \\]\n","date":1608472923,"description":"","lastmod":"2020-12-20T15:02:03+01:00","objectID":"cbe81b155c208abeab7f506e4f2dc62f","permalink":"https://yrrapt.github.io/analogue/design/inductor/inductor-design/","publishdate":"2020-12-20T15:02:03+01:00","title":"Inductor Design"},{"content":" On-Chip Spiral Inductors for RF Applications: An Overview A Fundamental Approach for Design and Optimization of a Spiral Inductor  ","date":-62135596800,"description":"","objectID":"2e3bf170f228e0072e42ebd0437d3188","permalink":"https://yrrapt.github.io/analogue/design/inductor/references/","title":"Inductor References"},{"content":"Notes about inductors.\n","date":1608472923,"description":"","lastmod":"2020-12-20T15:02:03+01:00","objectID":"3afa34c77b6fafafbd243cdadf9bb36e","permalink":"https://yrrapt.github.io/analogue/design/inductor/","title":"Inductors"},{"content":"Jitter Considering the jitter from a white noise source on a sinusoidal signal described by:\n\\[ v(t) = A sin( \\omega_0 t) + n(t) \\]\nGiven the assumption that the amplitude of the signal is much greater than the noise the transition times are only slightly modified. The small signal approximation can be made where:\n\\[ v(t) \\approx A \\omega_0 t + n(t) \\]\nFind when the signal equals zero at time moment k.\n\\[ 0 \\approx A \\omega_0 t_k + n_k \\]\nThus,\n\\[ t_k \\approx \\frac{n_k}{A \\omega_0} \\]\nTherefore, the jitter increases with larger noise amplitude, smaller signal amplitude or lower frequency.\nThe discrete-time noise process \\( n_k \\) is white with variance \\( \\sigma^2_n \\). Hence absolute jitter is also a discrete-time white noise process with variance:\n\\[ \\sigma^2_\\tau = \\frac{\\sigma^2_n}{A^2 \\omega^2_0} \\]\nThe sequence \\( \\tau_k \\) is the absolute jitter of the clock in time units. It can be normalised to radians:\n\\[ \\phi_k = \\tau_k \\frac{2 \\pi}{T_0} = \\frac{\\sigma^2_n}{A^2}\\]\nThe noise in radians is expressed as:\n\\[ \\sigma^2_\\phi = \\sigma^2_\\tau \\cdot {\\left( \\frac{2 \\pi}{T_0} \\right)}^2 = \\frac{\\sigma^2_n}{A^2} \\]\nPhase Noise Phase noise is the frequency-domain representation of absolute jitter. The phase noise, \\( S_\\phi(f) \\), of a clock signal with random jitter is the power spectral density of the sequence \\( \\phi_k \\). It specifies the power of \\( \\phi_k \\) in \\( rad^2 \\) within any 1 Hz wide bin of frequency spectrum and has units \\( rad^2 / Hz \\).\nThe variance of \\( \\phi_k \\) is given by the integral of \\( S_\\phi(f) \\) over all frequencies:\n\\[ \\sigma^2_\\tau = {\\left ( \\frac{T_0}{2 \\pi} \\right)}^2 \\int^{1/2T_0}_0 S_\\phi (f) \\cdot df \\]\nNormalised Power Spectral Density \\begin{tikzpicture} \\draw (0,0) circle (1in); \\end{tikzpicture}   [1] Carusone, T. C., Johns, D., Martin, K. W., \u0026amp;amp; Johns, D. (2012). Analog integrated circuit design. Hoboken, NJ: John Wiley \u0026amp;amp; Sons.\n","date":-62135596800,"description":"","objectID":"6ce8dc569cce7220266c433412d526c5","permalink":"https://yrrapt.github.io/analogue/design/pll/phase-noise/","title":"Jitter and Phase Noise Principles"},{"content":" Spur Reduction Techniques for Phase-Locked Loops Exploiting A Sub-Sampling Phase Detector A Noise-Shifting Differential Colpitts VCO  ","date":-62135596800,"description":"","objectID":"b59764e75ba72ed72fa2b9b1665d004d","permalink":"https://yrrapt.github.io/analogue/design/pll/references/","title":"PLL References"},{"content":"\\[ P = \\frac{1}{2} \\oint_S \\mathbf{E} \\times \\mathbf{H}^* = \\cdot d\\mathbf{s} = P_l + 2 j \\omega ~ (W_m - W_e) \\]\n [1] R. Aparicio and A. Hajimiri, \u0026amp;quot;A noise-shifting differential Colpitts VCO,\u0026amp;quot; in IEEE Journal of Solid-State Circuits, vol. 37, no. 12, pp. 1728-1736, Dec. 2002, doi: 10.1109/JSSC.2002.804354.\n","date":-62135596800,"description":"","objectID":"fd62fa6f7e5280dfb9e5de133de21072","permalink":"https://yrrapt.github.io/analogue/design/pll/vco-design/","title":"VCO Design"},{"content":"","date":-62135596800,"description":"","objectID":"b7d57c36cc56d1084411eb0cfbaecad2","permalink":"https://yrrapt.github.io/analogue/design/pll/","title":"PLL"},{"content":"Phase Noise  Efficient transient noise analysis of non-periodic mixed analogue/digital circuits  ","date":-62135596800,"description":"","objectID":"1542359853c05602b56d7338daa8e1fd","permalink":"https://yrrapt.github.io/analogue/design/simulation/references/","title":"Simulation References"},{"content":"Notes about design.\n","date":1490227200,"description":"","lastmod":"2017-03-23T00:00:00Z","objectID":"02e0f483cea2e38f39ceb042265c10ee","permalink":"https://yrrapt.github.io/analogue/design/","publishdate":"2017-03-24T00:00:00Z","title":"Design"},{"content":"ADC Verification Techniques ADC DNL/INL Measurement From https://www.reddit.com/r/chipdesign/comments/g9fsyg/dnlinl_of_adc_in_cadence:\n I never use the DNL \u0026amp;amp; INL calculator. It is so easy to get garbage answers with it. I\u0026amp;rsquo;ve never figured out how to do it reliably. Luckily, it is trivial to do this in Python. First, strobe the output codes of the ADC at the sampling rate and then save them to a file. Just a list. So, the list would look like: 0 0 0 0 0 0 0 ... 0 1 1 1 1 1 1 ... 1 2 2 2 2 2... 2 and so on.\nThen in Python, MATLAB, or whatever, read in the file and find the average number of samples per code (this is easy, just divide the total number of samples you have by the 2^N of your ADC where N is the resolution). This is your expected value of samples in each code bin.\nThen, do a loop over each code (from 0 to (2^N - 1)). The DNL for each code is simply the difference between the number of codes for that code divided by the average number of samples per code (the expected value). The INL is simply the previous INL plus the current DNL value (i.e the running sum for all previous DNLs value plus the current DNL value). Make sure to initialize INL to 0.\nThat\u0026amp;rsquo;s all there is to it. Just be sure to use an ideal voltage source for the ramp.\nIf you want to do a sine test, it is more involved, but still pretty easy.\nSo, one more thing, how many points do you need? The DNL resolution is 1/(Number of samples per code).\nSo, if you want to know your DNL to 0.1 LSB accuracy, you need 10 samples per code. So if you have a 12-bit ADC, you need 10*2^10 = 10,240 samples minimum.\nUsually you probably want more like 0.01 LSB accuracy so you would need 102,400 samples. If you do a sine test you need WAY more.\n ","date":1608472923,"description":"","lastmod":"2020-12-20T15:02:03+01:00","objectID":"92b30bde21c8fea54745b9648efae8cf","permalink":"https://yrrapt.github.io/analogue/verification/adc_verification/","publishdate":"2020-12-20T15:02:03+01:00","title":"ADC Verification Techniques"},{"content":"","date":1608472923,"description":"","lastmod":"2020-12-20T15:02:03+01:00","objectID":"a2160426b90e5d643fafd1d4c85e0e6c","permalink":"https://yrrapt.github.io/analogue/verification/","title":"Verification"},{"content":"","date":1608472923,"description":"","lastmod":"2020-12-20T15:02:03+01:00","objectID":"d07003b780667fc2b806c1f10301c642","permalink":"https://yrrapt.github.io/analogue/","title":"Analogue"}]